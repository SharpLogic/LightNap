/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * LightNap.WebApi
 * OpenAPI spec version: 1.0
 */
import { HttpClient } from "@angular/common/http";
import type { HttpContext, HttpEvent, HttpHeaders, HttpParams, HttpResponse as AngularHttpResponse } from "@angular/common/http";

import { Injectable, inject } from "@angular/core";

import { Observable } from "rxjs";

import type {
  AddUserClaimBodyOne,
  AddUserClaimBodyThree,
  AddUserClaimBodyTwo,
  AdminExternalLoginDtoPagedResponseDto,
  AdminSearchUsersRequestDto,
  AdminUpdateUserRequestDto,
  ChangeEmailRequestDto,
  ChangePasswordRequestDto,
  ClaimDtoPagedResponseDto,
  CompleteExternalLoginBodyOne,
  CompleteExternalLoginBodyThree,
  CompleteExternalLoginBodyTwo,
  ConfirmEmailChangeRequestDto,
  CreateStaticContentDto,
  CreateStaticContentLanguageDto,
  DeviceDto,
  ExternalLoginRegisterRequestDto,
  ExternalLoginSuccessDto,
  GetMyExternalLogins200OneItem,
  GetMyExternalLogins200ThreeItem,
  GetMyExternalLogins200TwoItem,
  GetMyUserClaimsBodyOne,
  GetMyUserClaimsBodyThree,
  GetMyUserClaimsBodyTwo,
  GetUser200One,
  GetUser200Three,
  GetUser200Two,
  GetUserByUserName200One,
  GetUserByUserName200Three,
  GetUserByUserName200Two,
  GetUsersByIds200OneItem,
  GetUsersByIds200ThreeItem,
  GetUsersByIds200TwoItem,
  LoginRequestDto,
  LoginSuccessDto,
  NewPasswordRequestDto,
  NotificationSearchResultsDto,
  ProfileDto,
  PublicUserDtoPagedResponseDto,
  PublishedStaticContentResultDto,
  RegisterRequestDto,
  RemoveUserClaimBodyOne,
  RemoveUserClaimBodyThree,
  RemoveUserClaimBodyTwo,
  ResetPasswordRequestDto,
  RoleDto,
  SearchClaimRequestDto,
  SearchClaimsBodyOne,
  SearchClaimsBodyThree,
  SearchClaimsBodyTwo,
  SearchExternalLoginsRequestDto,
  SearchNotificationsRequestDto,
  SearchStaticContentRequestDto,
  SearchUserClaimsRequestDto,
  SendMagicLinkRequestDto,
  SendVerificationEmailRequestDto,
  SetUserSettingRequestDto,
  StaticContentDto,
  StaticContentDtoPagedResponseDto,
  StaticContentSupportedLanguageDto,
  StringPagedResponseDto,
  SupportedExternalLoginDto,
  UpdateProfileRequestDto,
  UpdateStaticContentBodyOne,
  UpdateStaticContentBodyThree,
  UpdateStaticContentBodyTwo,
  UpdateStaticContentLanguageBodyOne,
  UpdateStaticContentLanguageBodyThree,
  UpdateStaticContentLanguageBodyTwo,
  UserClaimDtoPagedResponseDto,
  UserSettingDto,
  VerifyCodeRequestDto,
  VerifyEmailRequestDto,
} from "../models";

import { faker } from "@faker-js/faker";

import { HttpResponse, delay, http } from "msw";
import type { RequestHandlerOptions } from "msw";

import {
  ExternalLoginSuccessType,
  LoginSuccessType,
  NotificationStatus,
  NotificationType,
  StaticContentFormat,
  StaticContentReadAccess,
  StaticContentStatus,
  StaticContentType,
  StaticContentUserVisibility,
} from "../models";
import type {
  AdminExternalLoginDto,
  AdminUserDto,
  ClaimDto,
  ExternalLoginDto,
  PrivilegedUserDto,
  PublicUserDto,
  PublishedStaticContentDto,
  StaticContentLanguageDto,
  UserClaimDto,
} from "../models";

interface HttpClientOptions {
  headers?: HttpHeaders | Record<string, string | string[]>;
  context?: HttpContext;
  params?: HttpParams | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;
  reportProgress?: boolean;
  withCredentials?: boolean;
  credentials?: RequestCredentials;
  keepalive?: boolean;
  priority?: RequestPriority;
  cache?: RequestCache;
  mode?: RequestMode;
  redirect?: RequestRedirect;
  referrer?: string;
  integrity?: string;
  transferCache?: { includeHeaders?: string[] } | boolean;
  timeout?: number;
}

@Injectable({ providedIn: "root" })
export class LightNapWebApiService {
  private readonly http = inject(HttpClient);
  /**
   * @summary Retrieves published static content by key and language code.
   */
  getPublishedStaticContent<TData = PublishedStaticContentResultDto>(
    key: string,
    languageCode: string,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  getPublishedStaticContent<TData = PublishedStaticContentResultDto>(
    key: string,
    languageCode: string,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  getPublishedStaticContent<TData = PublishedStaticContentResultDto>(
    key: string,
    languageCode: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getPublishedStaticContent<TData = PublishedStaticContentResultDto>(
    key: string,
    languageCode: string,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.get<TData>(`/api/Content/published/${key}/${languageCode}`, options);
  }

  /**
   * @summary Retrieves the list of supported languages for static content.
   */
  getSupportedLanguages<TData = StaticContentSupportedLanguageDto[] | null>(options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getSupportedLanguages<TData = StaticContentSupportedLanguageDto[] | null>(
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  getSupportedLanguages<TData = StaticContentSupportedLanguageDto[] | null>(
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getSupportedLanguages<TData = StaticContentSupportedLanguageDto[] | null>(options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/Content/supported-languages`, options);
  }

  /**
   * Requires Administrator or ContentEditor role.
   * @summary Creates a new static content resource.
   */
  createStaticContent<TData = StaticContentDto>(
    createStaticContentDto: CreateStaticContentDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  createStaticContent<TData = StaticContentDto>(
    createStaticContentDto: CreateStaticContentDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  createStaticContent<TData = StaticContentDto>(
    createStaticContentDto: CreateStaticContentDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  createStaticContent<TData = StaticContentDto>(
    createStaticContentDto: CreateStaticContentDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Content`, createStaticContentDto, options);
  }

  /**
   * @summary Retrieves static content by its key.
   */
  getStaticContent<TData = StaticContentDto>(key: string, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getStaticContent<TData = StaticContentDto>(key: string, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  getStaticContent<TData = StaticContentDto>(
    key: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getStaticContent<TData = StaticContentDto>(key: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/Content/${key}`, options);
  }

  /**
   * @summary Updates an existing static content resource.
   */
  updateStaticContent<TData = StaticContentDto>(
    key: string,
    updateStaticContentBody: UpdateStaticContentBodyOne | UpdateStaticContentBodyTwo | UpdateStaticContentBodyThree,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  updateStaticContent<TData = StaticContentDto>(
    key: string,
    updateStaticContentBody: UpdateStaticContentBodyOne | UpdateStaticContentBodyTwo | UpdateStaticContentBodyThree,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  updateStaticContent<TData = StaticContentDto>(
    key: string,
    updateStaticContentBody: UpdateStaticContentBodyOne | UpdateStaticContentBodyTwo | UpdateStaticContentBodyThree,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  updateStaticContent<TData = StaticContentDto>(
    key: string,
    updateStaticContentBody: UpdateStaticContentBodyOne | UpdateStaticContentBodyTwo | UpdateStaticContentBodyThree,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.put<TData>(`/api/Content/${key}`, updateStaticContentBody, options);
  }

  /**
   * Requires Administrator role.
   * @summary Deletes a static content resource by its key.
   */
  deleteStaticContent<TData = boolean>(key: string, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  deleteStaticContent<TData = boolean>(key: string, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  deleteStaticContent<TData = boolean>(key: string, options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  deleteStaticContent<TData = boolean>(key: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.delete<TData>(`/api/Content/${key}`, options);
  }

  /**
   * Requires Administrator or ContentEditor role.
   * @summary Searches for static content based on the provided criteria.
   */
  searchStaticContent<TData = StaticContentDtoPagedResponseDto>(
    searchStaticContentRequestDto: SearchStaticContentRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  searchStaticContent<TData = StaticContentDtoPagedResponseDto>(
    searchStaticContentRequestDto: SearchStaticContentRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  searchStaticContent<TData = StaticContentDtoPagedResponseDto>(
    searchStaticContentRequestDto: SearchStaticContentRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  searchStaticContent<TData = StaticContentDtoPagedResponseDto>(
    searchStaticContentRequestDto: SearchStaticContentRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Content/search`, searchStaticContentRequestDto, options);
  }

  /**
   * @summary Retrieves a specific language version of static content.
   */
  getStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  getStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  getStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.get<TData>(`/api/Content/${key}/languages/${languageCode}`, options);
  }

  /**
   * @summary Creates a new language version for an existing static content resource.
   */
  createStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    createStaticContentLanguageDto: CreateStaticContentLanguageDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  createStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    createStaticContentLanguageDto: CreateStaticContentLanguageDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  createStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    createStaticContentLanguageDto: CreateStaticContentLanguageDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  createStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    createStaticContentLanguageDto: CreateStaticContentLanguageDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Content/${key}/languages/${languageCode}`, createStaticContentLanguageDto, options);
  }

  /**
   * @summary Updates a language version of static content.
   */
  updateStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    updateStaticContentLanguageBody: UpdateStaticContentLanguageBodyOne | UpdateStaticContentLanguageBodyTwo | UpdateStaticContentLanguageBodyThree,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  updateStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    updateStaticContentLanguageBody: UpdateStaticContentLanguageBodyOne | UpdateStaticContentLanguageBodyTwo | UpdateStaticContentLanguageBodyThree,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  updateStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    updateStaticContentLanguageBody: UpdateStaticContentLanguageBodyOne | UpdateStaticContentLanguageBodyTwo | UpdateStaticContentLanguageBodyThree,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  updateStaticContentLanguage<TData = StaticContentLanguageDto>(
    key: string,
    languageCode: string,
    updateStaticContentLanguageBody: UpdateStaticContentLanguageBodyOne | UpdateStaticContentLanguageBodyTwo | UpdateStaticContentLanguageBodyThree,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.put<TData>(`/api/Content/${key}/languages/${languageCode}`, updateStaticContentLanguageBody, options);
  }

  /**
   * Requires Administrator role.
   * @summary Deletes a language version of static content.
   */
  deleteStaticContentLanguage<TData = boolean>(
    key: string,
    languageCode: string,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  deleteStaticContentLanguage<TData = boolean>(
    key: string,
    languageCode: string,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  deleteStaticContentLanguage<TData = boolean>(
    key: string,
    languageCode: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  deleteStaticContentLanguage<TData = boolean>(key: string, languageCode: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.delete<TData>(`/api/Content/${key}/languages/${languageCode}`, options);
  }

  /**
   * @summary Retrieves all language versions of a static content resource.
   */
  getStaticContentLanguages<TData = StaticContentLanguageDto[] | null>(
    key: string,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  getStaticContentLanguages<TData = StaticContentLanguageDto[] | null>(
    key: string,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  getStaticContentLanguages<TData = StaticContentLanguageDto[] | null>(
    key: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getStaticContentLanguages<TData = StaticContentLanguageDto[] | null>(
    key: string,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.get<TData>(`/api/Content/${key}/languages`, options);
  }

  /**
   * @summary Gets the supported external login providers based on the application's configuration.
   */
  getSupportedExternalLogins<TData = SupportedExternalLoginDto[] | null>(options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getSupportedExternalLogins<TData = SupportedExternalLoginDto[] | null>(
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  getSupportedExternalLogins<TData = SupportedExternalLoginDto[] | null>(
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getSupportedExternalLogins<TData = SupportedExternalLoginDto[] | null>(options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/ExternalLogin/supported`, options);
  }

  /**
   * @summary Gets the supported external login providers based on the application's configuration.
   */
  searchExternalLogins<TData = AdminExternalLoginDtoPagedResponseDto>(
    searchExternalLoginsRequestDto: SearchExternalLoginsRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  searchExternalLogins<TData = AdminExternalLoginDtoPagedResponseDto>(
    searchExternalLoginsRequestDto: SearchExternalLoginsRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  searchExternalLogins<TData = AdminExternalLoginDtoPagedResponseDto>(
    searchExternalLoginsRequestDto: SearchExternalLoginsRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  searchExternalLogins<TData = AdminExternalLoginDtoPagedResponseDto>(
    searchExternalLoginsRequestDto: SearchExternalLoginsRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/ExternalLogin/search`, searchExternalLoginsRequestDto, options);
  }

  /**
 * This operation requires administrator privileges. Removing an external login may
            affect the user's ability to sign in using that provider.
 * @summary Removes an external login association from the specified user account.
 */
  removeExternalLogin<TData = boolean>(
    userId: string,
    loginProvider: string,
    providerKey: string,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  removeExternalLogin<TData = boolean>(
    userId: string,
    loginProvider: string,
    providerKey: string,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  removeExternalLogin<TData = boolean>(
    userId: string,
    loginProvider: string,
    providerKey: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  removeExternalLogin<TData = boolean>(
    userId: string,
    loginProvider: string,
    providerKey: string,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.delete<TData>(`/api/ExternalLogin/remove/${userId}/${loginProvider}/${providerKey}`, options);
  }

  /**
   * @summary Confirms external login association with current user.
   */
  getExternalLoginResult<TData = ExternalLoginSuccessDto>(
    confirmationToken: string,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  getExternalLoginResult<TData = ExternalLoginSuccessDto>(
    confirmationToken: string,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  getExternalLoginResult<TData = ExternalLoginSuccessDto>(
    confirmationToken: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getExternalLoginResult<TData = ExternalLoginSuccessDto>(
    confirmationToken: string,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.get<TData>(`/api/ExternalLogin/result/${confirmationToken}`, options);
  }

  /**
   * @summary Completes the external login when the account is already linked.
   */
  completeExternalLogin<TData = LoginSuccessDto>(
    confirmationToken: string,
    completeExternalLoginBody: CompleteExternalLoginBodyOne | CompleteExternalLoginBodyTwo | CompleteExternalLoginBodyThree,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  completeExternalLogin<TData = LoginSuccessDto>(
    confirmationToken: string,
    completeExternalLoginBody: CompleteExternalLoginBodyOne | CompleteExternalLoginBodyTwo | CompleteExternalLoginBodyThree,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  completeExternalLogin<TData = LoginSuccessDto>(
    confirmationToken: string,
    completeExternalLoginBody: CompleteExternalLoginBodyOne | CompleteExternalLoginBodyTwo | CompleteExternalLoginBodyThree,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  completeExternalLogin<TData = LoginSuccessDto>(
    confirmationToken: string,
    completeExternalLoginBody: CompleteExternalLoginBodyOne | CompleteExternalLoginBodyTwo | CompleteExternalLoginBodyThree,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/ExternalLogin/complete/${confirmationToken}`, completeExternalLoginBody, options);
  }

  /**
   * @summary Completes the external login registration when the user is not logged in yet.
   */
  completeExternalLoginRegistration<TData = LoginSuccessDto>(
    confirmationToken: string,
    externalLoginRegisterRequestDto: ExternalLoginRegisterRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  completeExternalLoginRegistration<TData = LoginSuccessDto>(
    confirmationToken: string,
    externalLoginRegisterRequestDto: ExternalLoginRegisterRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  completeExternalLoginRegistration<TData = LoginSuccessDto>(
    confirmationToken: string,
    externalLoginRegisterRequestDto: ExternalLoginRegisterRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  completeExternalLoginRegistration<TData = LoginSuccessDto>(
    confirmationToken: string,
    externalLoginRegisterRequestDto: ExternalLoginRegisterRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/ExternalLogin/register/${confirmationToken}`, externalLoginRegisterRequestDto, options);
  }

  /**
   * @summary Logs in a user.
   */
  logIn<TData = LoginSuccessDto>(loginRequestDto: LoginRequestDto, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  logIn<TData = LoginSuccessDto>(loginRequestDto: LoginRequestDto, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  logIn<TData = LoginSuccessDto>(
    loginRequestDto: LoginRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  logIn<TData = LoginSuccessDto>(loginRequestDto: LoginRequestDto, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.post<TData>(`/api/Identity/login`, loginRequestDto, options);
  }

  /**
   * @summary Registers a new user.
   */
  register<TData = LoginSuccessDto>(registerRequestDto: RegisterRequestDto, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  register<TData = LoginSuccessDto>(
    registerRequestDto: RegisterRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  register<TData = LoginSuccessDto>(
    registerRequestDto: RegisterRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  register<TData = LoginSuccessDto>(registerRequestDto: RegisterRequestDto, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.post<TData>(`/api/Identity/register`, registerRequestDto, options);
  }

  /**
   * @summary Logs out the current user.
   */
  logOut<TData = boolean>(options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  logOut<TData = boolean>(options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  logOut<TData = boolean>(options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  logOut<TData = boolean>(options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/Identity/logout`, options);
  }

  /**
   * @summary Changes the password of the current user.
   */
  changePassword<TData = boolean>(
    changePasswordRequestDto: ChangePasswordRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  changePassword<TData = boolean>(
    changePasswordRequestDto: ChangePasswordRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  changePassword<TData = boolean>(
    changePasswordRequestDto: ChangePasswordRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  changePassword<TData = boolean>(
    changePasswordRequestDto: ChangePasswordRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Identity/change-password`, changePasswordRequestDto, options);
  }

  /**
   * @summary Changes the email of the current user.
   */
  changeEmail<TData = boolean>(changeEmailRequestDto: ChangeEmailRequestDto, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  changeEmail<TData = boolean>(
    changeEmailRequestDto: ChangeEmailRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  changeEmail<TData = boolean>(
    changeEmailRequestDto: ChangeEmailRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  changeEmail<TData = boolean>(changeEmailRequestDto: ChangeEmailRequestDto, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.post<TData>(`/api/Identity/change-email`, changeEmailRequestDto, options);
  }

  /**
   * @summary Confirms the email change of the current user.
   */
  confirmEmailChange<TData = boolean>(
    confirmEmailChangeRequestDto: ConfirmEmailChangeRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  confirmEmailChange<TData = boolean>(
    confirmEmailChangeRequestDto: ConfirmEmailChangeRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  confirmEmailChange<TData = boolean>(
    confirmEmailChangeRequestDto: ConfirmEmailChangeRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  confirmEmailChange<TData = boolean>(
    confirmEmailChangeRequestDto: ConfirmEmailChangeRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Identity/confirm-email-change`, confirmEmailChangeRequestDto, options);
  }

  /**
   * @summary Resets the password for a user.
   */
  resetPassword<TData = boolean>(
    resetPasswordRequestDto: ResetPasswordRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  resetPassword<TData = boolean>(
    resetPasswordRequestDto: ResetPasswordRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  resetPassword<TData = boolean>(
    resetPasswordRequestDto: ResetPasswordRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  resetPassword<TData = boolean>(resetPasswordRequestDto: ResetPasswordRequestDto, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.post<TData>(`/api/Identity/reset-password`, resetPasswordRequestDto, options);
  }

  /**
   * @summary Sets a new password for a user.
   */
  newPassword<TData = LoginSuccessDto>(
    newPasswordRequestDto: NewPasswordRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  newPassword<TData = LoginSuccessDto>(
    newPasswordRequestDto: NewPasswordRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  newPassword<TData = LoginSuccessDto>(
    newPasswordRequestDto: NewPasswordRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  newPassword<TData = LoginSuccessDto>(
    newPasswordRequestDto: NewPasswordRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Identity/new-password`, newPasswordRequestDto, options);
  }

  /**
   * @summary Verifies the two-factor authentication code.
   */
  verifyCode<TData = string | null>(
    verifyCodeRequestDto: VerifyCodeRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  verifyCode<TData = string | null>(
    verifyCodeRequestDto: VerifyCodeRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  verifyCode<TData = string | null>(
    verifyCodeRequestDto: VerifyCodeRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  verifyCode<TData = string | null>(verifyCodeRequestDto: VerifyCodeRequestDto, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.post<TData>(`/api/Identity/verify-code`, verifyCodeRequestDto, options);
  }

  /**
   * @summary Refreshes the access token using the refresh token.
   */
  getAccessToken<TData = string | null>(options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getAccessToken<TData = string | null>(options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  getAccessToken<TData = string | null>(options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  getAccessToken<TData = string | null>(options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/Identity/access-token`, options);
  }

  /**
   * @summary Requests an email verification email for a user.
   */
  requestVerificationEmail<TData = boolean>(
    sendVerificationEmailRequestDto: SendVerificationEmailRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  requestVerificationEmail<TData = boolean>(
    sendVerificationEmailRequestDto: SendVerificationEmailRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  requestVerificationEmail<TData = boolean>(
    sendVerificationEmailRequestDto: SendVerificationEmailRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  requestVerificationEmail<TData = boolean>(
    sendVerificationEmailRequestDto: SendVerificationEmailRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Identity/request-verification-email`, sendVerificationEmailRequestDto, options);
  }

  /**
   * @summary Verifies the email address of a user.
   */
  verifyEmail<TData = boolean>(verifyEmailRequestDto: VerifyEmailRequestDto, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  verifyEmail<TData = boolean>(
    verifyEmailRequestDto: VerifyEmailRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  verifyEmail<TData = boolean>(
    verifyEmailRequestDto: VerifyEmailRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  verifyEmail<TData = boolean>(verifyEmailRequestDto: VerifyEmailRequestDto, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.post<TData>(`/api/Identity/verify-email`, verifyEmailRequestDto, options);
  }

  /**
   * @summary Requests a magic link the user can use to log in.
   */
  requestMagicLinkEmail<TData = boolean>(
    sendMagicLinkRequestDto: SendMagicLinkRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  requestMagicLinkEmail<TData = boolean>(
    sendMagicLinkRequestDto: SendMagicLinkRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  requestMagicLinkEmail<TData = boolean>(
    sendMagicLinkRequestDto: SendMagicLinkRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  requestMagicLinkEmail<TData = boolean>(
    sendMagicLinkRequestDto: SendMagicLinkRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Identity/request-magic-link`, sendMagicLinkRequestDto, options);
  }

  /**
   * @summary Retrieves the list of devices.
   */
  getDevices<TData = DeviceDto[] | null>(options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getDevices<TData = DeviceDto[] | null>(options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  getDevices<TData = DeviceDto[] | null>(options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  getDevices<TData = DeviceDto[] | null>(options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/Identity/devices`, options);
  }

  /**
   * @summary Revokes a device.
   */
  revokeDevice<TData = boolean>(deviceId: string, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  revokeDevice<TData = boolean>(deviceId: string, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  revokeDevice<TData = boolean>(deviceId: string, options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  revokeDevice<TData = boolean>(deviceId: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.delete<TData>(`/api/Identity/devices/${deviceId}`, options);
  }

  /**
   * @summary Retrieves the profile of the current user.
   */
  getProfile<TData = ProfileDto>(options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getProfile<TData = ProfileDto>(options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  getProfile<TData = ProfileDto>(options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  getProfile<TData = ProfileDto>(options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/users/me/profile`, options);
  }

  /**
   * @summary Updates the profile of the current user.
   */
  updateMyProfile<TData = ProfileDto>(
    updateProfileRequestDto: UpdateProfileRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  updateMyProfile<TData = ProfileDto>(
    updateProfileRequestDto: UpdateProfileRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  updateMyProfile<TData = ProfileDto>(
    updateProfileRequestDto: UpdateProfileRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  updateMyProfile<TData = ProfileDto>(
    updateProfileRequestDto: UpdateProfileRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.put<TData>(`/api/users/me/profile`, updateProfileRequestDto, options);
  }

  /**
   * @summary Searches the notifications of the current user.
   */
  searchMyNotifications<TData = NotificationSearchResultsDto>(
    searchNotificationsRequestDto: SearchNotificationsRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  searchMyNotifications<TData = NotificationSearchResultsDto>(
    searchNotificationsRequestDto: SearchNotificationsRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  searchMyNotifications<TData = NotificationSearchResultsDto>(
    searchNotificationsRequestDto: SearchNotificationsRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  searchMyNotifications<TData = NotificationSearchResultsDto>(
    searchNotificationsRequestDto: SearchNotificationsRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/users/me/notifications`, searchNotificationsRequestDto, options);
  }

  /**
   * @summary Marks all notifications as read for the current user.
   */
  markAllMyNotificationsAsRead<TData = boolean>(options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  markAllMyNotificationsAsRead<TData = boolean>(options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  markAllMyNotificationsAsRead<TData = boolean>(options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  markAllMyNotificationsAsRead<TData = boolean>(options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.put<TData>(`/api/users/me/notifications/mark-all-as-read`, undefined, options);
  }

  /**
   * @summary Marks a specific notification as read for the current user.
   */
  markMyNotificationAsRead<TData = boolean>(id: number, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  markMyNotificationAsRead<TData = boolean>(id: number, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  markMyNotificationAsRead<TData = boolean>(
    id: number,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  markMyNotificationAsRead<TData = boolean>(id: number, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.put<TData>(`/api/users/me/notifications/${id}/mark-as-read`, undefined, options);
  }

  /**
 * This method returns a list of claims for the user making the request. The claims
            provide  information about the user's identity, roles, or other attributes. The user must be authenticated
            to access this endpoint.
 * @summary Retrieves the claims associated with the currently authenticated user.
 */
  getMyUserClaims<TData = ClaimDtoPagedResponseDto>(
    getMyUserClaimsBody: GetMyUserClaimsBodyOne | GetMyUserClaimsBodyTwo | GetMyUserClaimsBodyThree,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  getMyUserClaims<TData = ClaimDtoPagedResponseDto>(
    getMyUserClaimsBody: GetMyUserClaimsBodyOne | GetMyUserClaimsBodyTwo | GetMyUserClaimsBodyThree,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  getMyUserClaims<TData = ClaimDtoPagedResponseDto>(
    getMyUserClaimsBody: GetMyUserClaimsBodyOne | GetMyUserClaimsBodyTwo | GetMyUserClaimsBodyThree,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getMyUserClaims<TData = ClaimDtoPagedResponseDto>(
    getMyUserClaimsBody: GetMyUserClaimsBodyOne | GetMyUserClaimsBodyTwo | GetMyUserClaimsBodyThree,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.get<TData>(`/api/users/me/claims`, options);
  }

  /**
   * @summary Gets the user settings for the current user.
   */
  getMyUserSettings<TData = UserSettingDto[] | null>(options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getMyUserSettings<TData = UserSettingDto[] | null>(options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  getMyUserSettings<TData = UserSettingDto[] | null>(options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  getMyUserSettings<TData = UserSettingDto[] | null>(options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/users/me/settings`, options);
  }

  /**
 * This method applies the changes to the user's settings and returns the updated
            setting in the response. Ensure that the provided request data is valid and complete before calling this
            method.
 * @summary Updates the user setting based on the provided request data.
 */
  setMyUserSetting<TData = UserSettingDto>(
    setUserSettingRequestDto: SetUserSettingRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  setMyUserSetting<TData = UserSettingDto>(
    setUserSettingRequestDto: SetUserSettingRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  setMyUserSetting<TData = UserSettingDto>(
    setUserSettingRequestDto: SetUserSettingRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  setMyUserSetting<TData = UserSettingDto>(
    setUserSettingRequestDto: SetUserSettingRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.patch<TData>(`/api/users/me/settings`, setUserSettingRequestDto, options);
  }

  /**
   * @summary Retrieves all external login providers linked to the current user.
   */
  getMyExternalLogins<
    TData = GetMyExternalLogins200OneItem[] | null | GetMyExternalLogins200TwoItem[] | null | GetMyExternalLogins200ThreeItem[] | null,
  >(options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getMyExternalLogins<
    TData = GetMyExternalLogins200OneItem[] | null | GetMyExternalLogins200TwoItem[] | null | GetMyExternalLogins200ThreeItem[] | null,
  >(options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  getMyExternalLogins<
    TData = GetMyExternalLogins200OneItem[] | null | GetMyExternalLogins200TwoItem[] | null | GetMyExternalLogins200ThreeItem[] | null,
  >(options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  getMyExternalLogins<
    TData = GetMyExternalLogins200OneItem[] | null | GetMyExternalLogins200TwoItem[] | null | GetMyExternalLogins200ThreeItem[] | null,
  >(options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/users/me/external-logins`, options);
  }

  /**
   * @summary Removes an external login provider from the current user's account.
   */
  removeMyExternalLogin<TData = boolean>(
    loginProvider: string,
    providerKey: string,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  removeMyExternalLogin<TData = boolean>(
    loginProvider: string,
    providerKey: string,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  removeMyExternalLogin<TData = boolean>(
    loginProvider: string,
    providerKey: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  removeMyExternalLogin<TData = boolean>(
    loginProvider: string,
    providerKey: string,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.delete<TData>(`/api/users/me/external-logins/${loginProvider}/${providerKey}`, options);
  }

  /**
   * @summary Retrieves a user by ID.
   */
  getUser<TData = GetUser200One | GetUser200Two | GetUser200Three>(
    userId: string,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  getUser<TData = GetUser200One | GetUser200Two | GetUser200Three>(
    userId: string,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  getUser<TData = GetUser200One | GetUser200Two | GetUser200Three>(
    userId: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getUser<TData = GetUser200One | GetUser200Two | GetUser200Three>(userId: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/Users/${userId}`, options);
  }

  /**
   * @summary Updates a user.
   */
  updateUser<TData = AdminUserDto>(
    userId: string,
    adminUpdateUserRequestDto: AdminUpdateUserRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  updateUser<TData = AdminUserDto>(
    userId: string,
    adminUpdateUserRequestDto: AdminUpdateUserRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  updateUser<TData = AdminUserDto>(
    userId: string,
    adminUpdateUserRequestDto: AdminUpdateUserRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  updateUser<TData = AdminUserDto>(
    userId: string,
    adminUpdateUserRequestDto: AdminUpdateUserRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.put<TData>(`/api/Users/${userId}`, adminUpdateUserRequestDto, options);
  }

  /**
   * @summary Deletes a user.
   */
  deleteUser<TData = boolean>(userId: string, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  deleteUser<TData = boolean>(userId: string, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  deleteUser<TData = boolean>(userId: string, options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  deleteUser<TData = boolean>(userId: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.delete<TData>(`/api/Users/${userId}`, options);
  }

  /**
   * @summary Retrieves a user by username.
   */
  getUserByUserName<TData = GetUserByUserName200One | GetUserByUserName200Two | GetUserByUserName200Three>(
    userName: string,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  getUserByUserName<TData = GetUserByUserName200One | GetUserByUserName200Two | GetUserByUserName200Three>(
    userName: string,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  getUserByUserName<TData = GetUserByUserName200One | GetUserByUserName200Two | GetUserByUserName200Three>(
    userName: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getUserByUserName<TData = GetUserByUserName200One | GetUserByUserName200Two | GetUserByUserName200Three>(
    userName: string,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.get<TData>(`/api/Users/user-name/${userName}`, options);
  }

  /**
   * @summary Searches for users based on the specified criteria.
   */
  searchUsers<TData = PublicUserDtoPagedResponseDto>(
    adminSearchUsersRequestDto: AdminSearchUsersRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  searchUsers<TData = PublicUserDtoPagedResponseDto>(
    adminSearchUsersRequestDto: AdminSearchUsersRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  searchUsers<TData = PublicUserDtoPagedResponseDto>(
    adminSearchUsersRequestDto: AdminSearchUsersRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  searchUsers<TData = PublicUserDtoPagedResponseDto>(
    adminSearchUsersRequestDto: AdminSearchUsersRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Users/search`, adminSearchUsersRequestDto, options);
  }

  /**
   * @summary Retrieves a list of users by their IDs.
   */
  getUsersByIds<TData = GetUsersByIds200OneItem[] | null | GetUsersByIds200TwoItem[] | null | GetUsersByIds200ThreeItem[] | null>(
    getUsersByIdsBody: string[],
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  getUsersByIds<TData = GetUsersByIds200OneItem[] | null | GetUsersByIds200TwoItem[] | null | GetUsersByIds200ThreeItem[] | null>(
    getUsersByIdsBody: string[],
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  getUsersByIds<TData = GetUsersByIds200OneItem[] | null | GetUsersByIds200TwoItem[] | null | GetUsersByIds200ThreeItem[] | null>(
    getUsersByIdsBody: string[],
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getUsersByIds<TData = GetUsersByIds200OneItem[] | null | GetUsersByIds200TwoItem[] | null | GetUsersByIds200ThreeItem[] | null>(
    getUsersByIdsBody: string[],
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Users/get-by-ids`, getUsersByIdsBody, options);
  }

  /**
   * @summary Retrieves all available roles.
   */
  getRoles<TData = RoleDto[] | null>(options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getRoles<TData = RoleDto[] | null>(options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  getRoles<TData = RoleDto[] | null>(options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  getRoles<TData = RoleDto[] | null>(options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/Users/roles`, options);
  }

  /**
   * @summary Retrieves the roles for a user.
   */
  getRolesForUser<TData = string[] | null>(userId: string, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getRolesForUser<TData = string[] | null>(userId: string, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  getRolesForUser<TData = string[] | null>(
    userId: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getRolesForUser<TData = string[] | null>(userId: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/Users/${userId}/roles`, options);
  }

  /**
   * @summary Retrieves the users in a specific role.
   */
  getUsersInRole<TData = AdminUserDto[] | null>(role: string, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getUsersInRole<TData = AdminUserDto[] | null>(role: string, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  getUsersInRole<TData = AdminUserDto[] | null>(
    role: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getUsersInRole<TData = AdminUserDto[] | null>(role: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/Users/roles/${role}`, options);
  }

  /**
   * @summary Adds a user to a role.
   */
  addUserToRole<TData = boolean>(role: string, userId: string, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  addUserToRole<TData = boolean>(role: string, userId: string, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  addUserToRole<TData = boolean>(
    role: string,
    userId: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  addUserToRole<TData = boolean>(role: string, userId: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.post<TData>(`/api/Users/roles/${role}/${userId}`, undefined, options);
  }

  /**
   * @summary Removes a user from a role.
   */
  removeUserFromRole<TData = boolean>(role: string, userId: string, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  removeUserFromRole<TData = boolean>(
    role: string,
    userId: string,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  removeUserFromRole<TData = boolean>(
    role: string,
    userId: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  removeUserFromRole<TData = boolean>(role: string, userId: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.delete<TData>(`/api/Users/roles/${role}/${userId}`, options);
  }

  /**
   * @summary Searches claims.
   */
  searchClaims<TData = ClaimDtoPagedResponseDto>(
    searchClaimsBody: SearchClaimsBodyOne | SearchClaimsBodyTwo | SearchClaimsBodyThree,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  searchClaims<TData = ClaimDtoPagedResponseDto>(
    searchClaimsBody: SearchClaimsBodyOne | SearchClaimsBodyTwo | SearchClaimsBodyThree,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  searchClaims<TData = ClaimDtoPagedResponseDto>(
    searchClaimsBody: SearchClaimsBodyOne | SearchClaimsBodyTwo | SearchClaimsBodyThree,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  searchClaims<TData = ClaimDtoPagedResponseDto>(
    searchClaimsBody: SearchClaimsBodyOne | SearchClaimsBodyTwo | SearchClaimsBodyThree,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Users/claims/search`, searchClaimsBody, options);
  }

  /**
   * @summary Searches user claims.
   */
  searchUserClaims<TData = UserClaimDtoPagedResponseDto>(
    searchUserClaimsRequestDto: SearchUserClaimsRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  searchUserClaims<TData = UserClaimDtoPagedResponseDto>(
    searchUserClaimsRequestDto: SearchUserClaimsRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  searchUserClaims<TData = UserClaimDtoPagedResponseDto>(
    searchUserClaimsRequestDto: SearchUserClaimsRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  searchUserClaims<TData = UserClaimDtoPagedResponseDto>(
    searchUserClaimsRequestDto: SearchUserClaimsRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Users/user-claims/search`, searchUserClaimsRequestDto, options);
  }

  /**
   * @summary Returns users with a specific claim.
   */
  getUsersWithClaim<TData = StringPagedResponseDto>(
    searchClaimRequestDto: SearchClaimRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  getUsersWithClaim<TData = StringPagedResponseDto>(
    searchClaimRequestDto: SearchClaimRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  getUsersWithClaim<TData = StringPagedResponseDto>(
    searchClaimRequestDto: SearchClaimRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getUsersWithClaim<TData = StringPagedResponseDto>(
    searchClaimRequestDto: SearchClaimRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Users/claim-users`, searchClaimRequestDto, options);
  }

  /**
   * @summary Adds a claim to a user.
   */
  addUserClaim<TData = boolean>(
    userId: string,
    addUserClaimBody: AddUserClaimBodyOne | AddUserClaimBodyTwo | AddUserClaimBodyThree,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  addUserClaim<TData = boolean>(
    userId: string,
    addUserClaimBody: AddUserClaimBodyOne | AddUserClaimBodyTwo | AddUserClaimBodyThree,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  addUserClaim<TData = boolean>(
    userId: string,
    addUserClaimBody: AddUserClaimBodyOne | AddUserClaimBodyTwo | AddUserClaimBodyThree,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  addUserClaim<TData = boolean>(
    userId: string,
    addUserClaimBody: AddUserClaimBodyOne | AddUserClaimBodyTwo | AddUserClaimBodyThree,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.post<TData>(`/api/Users/${userId}/claims`, addUserClaimBody, options);
  }

  /**
   * @summary Removes a claim from a user.
   */
  removeUserClaim<TData = boolean>(
    userId: string,
    removeUserClaimBody: RemoveUserClaimBodyOne | RemoveUserClaimBodyTwo | RemoveUserClaimBodyThree,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  removeUserClaim<TData = boolean>(
    userId: string,
    removeUserClaimBody: RemoveUserClaimBodyOne | RemoveUserClaimBodyTwo | RemoveUserClaimBodyThree,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  removeUserClaim<TData = boolean>(
    userId: string,
    removeUserClaimBody: RemoveUserClaimBodyOne | RemoveUserClaimBodyTwo | RemoveUserClaimBodyThree,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  removeUserClaim<TData = boolean>(
    userId: string,
    removeUserClaimBody: RemoveUserClaimBodyOne | RemoveUserClaimBodyTwo | RemoveUserClaimBodyThree,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.delete<TData>(`/api/Users/${userId}/claims`, { body: removeUserClaimBody, ...options });
  }

  /**
   * @summary Locks a user account.
   */
  lockUserAccount<TData = boolean>(userId: string, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  lockUserAccount<TData = boolean>(userId: string, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  lockUserAccount<TData = boolean>(userId: string, options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  lockUserAccount<TData = boolean>(userId: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.post<TData>(`/api/Users/${userId}/lock`, undefined, options);
  }

  /**
   * @summary Unlocks a user account.
   */
  unlockUserAccount<TData = boolean>(userId: string, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  unlockUserAccount<TData = boolean>(userId: string, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  unlockUserAccount<TData = boolean>(userId: string, options?: HttpClientOptions & { observe: "response" }): Observable<AngularHttpResponse<TData>>;
  unlockUserAccount<TData = boolean>(userId: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.post<TData>(`/api/Users/${userId}/unlock`, undefined, options);
  }

  /**
   * @summary Gets the settings for a user.
   */
  getUserSettings<TData = UserSettingDto[] | null>(userId: string, options?: HttpClientOptions & { observe?: "body" }): Observable<TData>;
  getUserSettings<TData = UserSettingDto[] | null>(userId: string, options?: HttpClientOptions & { observe: "events" }): Observable<HttpEvent<TData>>;
  getUserSettings<TData = UserSettingDto[] | null>(
    userId: string,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  getUserSettings<TData = UserSettingDto[] | null>(userId: string, options?: HttpClientOptions & { observe?: any }): Observable<any> {
    return this.http.get<TData>(`/api/Users/${userId}/settings`, options);
  }

  /**
 * This method requires the caller to have the Administrator role. It is intended to be
            used for managing user-specific settings.
 * @summary Updates the settings for a specific user.
 */
  setUserSetting<TData = UserSettingDto>(
    userId: string,
    setUserSettingRequestDto: SetUserSettingRequestDto,
    options?: HttpClientOptions & { observe?: "body" }
  ): Observable<TData>;
  setUserSetting<TData = UserSettingDto>(
    userId: string,
    setUserSettingRequestDto: SetUserSettingRequestDto,
    options?: HttpClientOptions & { observe: "events" }
  ): Observable<HttpEvent<TData>>;
  setUserSetting<TData = UserSettingDto>(
    userId: string,
    setUserSettingRequestDto: SetUserSettingRequestDto,
    options?: HttpClientOptions & { observe: "response" }
  ): Observable<AngularHttpResponse<TData>>;
  setUserSetting<TData = UserSettingDto>(
    userId: string,
    setUserSettingRequestDto: SetUserSettingRequestDto,
    options?: HttpClientOptions & { observe?: any }
  ): Observable<any> {
    return this.http.put<TData>(`/api/Users/${userId}/settings`, setUserSettingRequestDto, options);
  }
}

export type GetPublishedStaticContentClientResult = NonNullable<PublishedStaticContentResultDto>;
export type GetSupportedLanguagesClientResult = NonNullable<StaticContentSupportedLanguageDto[] | null>;
export type CreateStaticContentClientResult = NonNullable<StaticContentDto>;
export type GetStaticContentClientResult = NonNullable<StaticContentDto>;
export type UpdateStaticContentClientResult = NonNullable<StaticContentDto>;
export type DeleteStaticContentClientResult = NonNullable<boolean>;
export type SearchStaticContentClientResult = NonNullable<StaticContentDtoPagedResponseDto>;
export type GetStaticContentLanguageClientResult = NonNullable<StaticContentLanguageDto>;
export type CreateStaticContentLanguageClientResult = NonNullable<StaticContentLanguageDto>;
export type UpdateStaticContentLanguageClientResult = NonNullable<StaticContentLanguageDto>;
export type DeleteStaticContentLanguageClientResult = NonNullable<boolean>;
export type GetStaticContentLanguagesClientResult = NonNullable<StaticContentLanguageDto[] | null>;
export type GetSupportedExternalLoginsClientResult = NonNullable<SupportedExternalLoginDto[] | null>;
export type SearchExternalLoginsClientResult = NonNullable<AdminExternalLoginDtoPagedResponseDto>;
export type RemoveExternalLoginClientResult = NonNullable<boolean>;
export type GetExternalLoginResultClientResult = NonNullable<ExternalLoginSuccessDto>;
export type CompleteExternalLoginClientResult = NonNullable<LoginSuccessDto>;
export type CompleteExternalLoginRegistrationClientResult = NonNullable<LoginSuccessDto>;
export type LogInClientResult = NonNullable<LoginSuccessDto>;
export type RegisterClientResult = NonNullable<LoginSuccessDto>;
export type LogOutClientResult = NonNullable<boolean>;
export type ChangePasswordClientResult = NonNullable<boolean>;
export type ChangeEmailClientResult = NonNullable<boolean>;
export type ConfirmEmailChangeClientResult = NonNullable<boolean>;
export type ResetPasswordClientResult = NonNullable<boolean>;
export type NewPasswordClientResult = NonNullable<LoginSuccessDto>;
export type VerifyCodeClientResult = NonNullable<string | null>;
export type GetAccessTokenClientResult = NonNullable<string | null>;
export type RequestVerificationEmailClientResult = NonNullable<boolean>;
export type VerifyEmailClientResult = NonNullable<boolean>;
export type RequestMagicLinkEmailClientResult = NonNullable<boolean>;
export type GetDevicesClientResult = NonNullable<DeviceDto[] | null>;
export type RevokeDeviceClientResult = NonNullable<boolean>;
export type GetProfileClientResult = NonNullable<ProfileDto>;
export type UpdateMyProfileClientResult = NonNullable<ProfileDto>;
export type SearchMyNotificationsClientResult = NonNullable<NotificationSearchResultsDto>;
export type MarkAllMyNotificationsAsReadClientResult = NonNullable<boolean>;
export type MarkMyNotificationAsReadClientResult = NonNullable<boolean>;
export type GetMyUserClaimsClientResult = NonNullable<ClaimDtoPagedResponseDto>;
export type GetMyUserSettingsClientResult = NonNullable<UserSettingDto[] | null>;
export type SetMyUserSettingClientResult = NonNullable<UserSettingDto>;
export type GetMyExternalLoginsClientResult = NonNullable<
  GetMyExternalLogins200OneItem[] | null | GetMyExternalLogins200TwoItem[] | null | GetMyExternalLogins200ThreeItem[] | null
>;
export type RemoveMyExternalLoginClientResult = NonNullable<boolean>;
export type GetUserClientResult = NonNullable<GetUser200One | GetUser200Two | GetUser200Three>;
export type UpdateUserClientResult = NonNullable<AdminUserDto>;
export type DeleteUserClientResult = NonNullable<boolean>;
export type GetUserByUserNameClientResult = NonNullable<GetUserByUserName200One | GetUserByUserName200Two | GetUserByUserName200Three>;
export type SearchUsersClientResult = NonNullable<PublicUserDtoPagedResponseDto>;
export type GetUsersByIdsClientResult = NonNullable<
  GetUsersByIds200OneItem[] | null | GetUsersByIds200TwoItem[] | null | GetUsersByIds200ThreeItem[] | null
>;
export type GetRolesClientResult = NonNullable<RoleDto[] | null>;
export type GetRolesForUserClientResult = NonNullable<string[] | null>;
export type GetUsersInRoleClientResult = NonNullable<AdminUserDto[] | null>;
export type AddUserToRoleClientResult = NonNullable<boolean>;
export type RemoveUserFromRoleClientResult = NonNullable<boolean>;
export type SearchClaimsClientResult = NonNullable<ClaimDtoPagedResponseDto>;
export type SearchUserClaimsClientResult = NonNullable<UserClaimDtoPagedResponseDto>;
export type GetUsersWithClaimClientResult = NonNullable<StringPagedResponseDto>;
export type AddUserClaimClientResult = NonNullable<boolean>;
export type RemoveUserClaimClientResult = NonNullable<boolean>;
export type LockUserAccountClientResult = NonNullable<boolean>;
export type UnlockUserAccountClientResult = NonNullable<boolean>;
export type GetUserSettingsClientResult = NonNullable<UserSettingDto[] | null>;
export type SetUserSettingClientResult = NonNullable<UserSettingDto>;

export const getGetPublishedStaticContentResponsePublishedStaticContentDtoMock = (
  overrideResponse: Partial<PublishedStaticContentDto> = {}
): PublishedStaticContentDto => ({
  ...{ content: faker.string.alpha({ length: { min: 10, max: 20 } }), format: faker.helpers.arrayElement(Object.values(StaticContentFormat)) },
  ...overrideResponse,
});

export const getGetPublishedStaticContentResponseStaticContentLanguageDtoMock = (
  overrideResponse: Partial<StaticContentLanguageDto> = {}
): StaticContentLanguageDto => ({
  ...{
    ...{
      ...{ content: faker.string.alpha({ length: { min: 10, max: 20 } }), format: faker.helpers.arrayElement(Object.values(StaticContentFormat)) },
    },
    staticContentId: faker.number.int({ min: undefined, max: undefined }),
    languageCode: faker.string.alpha({ length: { min: 10, max: 20 } }),
    createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
    createdByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
    lastModifiedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
    lastModifiedUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  },
  ...overrideResponse,
});

export const getGetPublishedStaticContentResponseMock = (
  overrideResponse: Partial<PublishedStaticContentResultDto> = {}
): PublishedStaticContentResultDto => ({
  visibility: faker.helpers.arrayElement(Object.values(StaticContentUserVisibility)),
  content: faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      { ...getGetPublishedStaticContentResponsePublishedStaticContentDtoMock() },
      { ...getGetPublishedStaticContentResponseStaticContentLanguageDtoMock() },
    ]),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetSupportedLanguagesResponseMock = (): StaticContentSupportedLanguageDto[] | null =>
  Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    languageCode: faker.string.alpha({ length: { min: 10, max: 20 } }),
    languageName: faker.string.alpha({ length: { min: 10, max: 20 } }),
  }));

export const getCreateStaticContentResponseMock = (overrideResponse: Partial<StaticContentDto> = {}): StaticContentDto => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  type: faker.helpers.arrayElement(Object.values(StaticContentType)),
  key: faker.string.alpha({ length: { min: 10, max: 20 } }),
  status: faker.helpers.arrayElement(Object.values(StaticContentStatus)),
  readAccess: faker.helpers.arrayElement(Object.values(StaticContentReadAccess)),
  editorRoles: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  readerRoles: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
  createdByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  statusChangedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
  statusChangedByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  lastModifiedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
  lastModifiedByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  ...overrideResponse,
});

export const getGetStaticContentResponseMock = (overrideResponse: Partial<StaticContentDto> = {}): StaticContentDto => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  type: faker.helpers.arrayElement(Object.values(StaticContentType)),
  key: faker.string.alpha({ length: { min: 10, max: 20 } }),
  status: faker.helpers.arrayElement(Object.values(StaticContentStatus)),
  readAccess: faker.helpers.arrayElement(Object.values(StaticContentReadAccess)),
  editorRoles: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  readerRoles: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
  createdByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  statusChangedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
  statusChangedByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  lastModifiedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
  lastModifiedByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  ...overrideResponse,
});

export const getUpdateStaticContentResponseMock = (overrideResponse: Partial<StaticContentDto> = {}): StaticContentDto => ({
  id: faker.number.int({ min: undefined, max: undefined }),
  type: faker.helpers.arrayElement(Object.values(StaticContentType)),
  key: faker.string.alpha({ length: { min: 10, max: 20 } }),
  status: faker.helpers.arrayElement(Object.values(StaticContentStatus)),
  readAccess: faker.helpers.arrayElement(Object.values(StaticContentReadAccess)),
  editorRoles: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  readerRoles: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
  createdByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  statusChangedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
  statusChangedByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  lastModifiedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
  lastModifiedByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  ...overrideResponse,
});

export const getDeleteStaticContentResponseMock = (): boolean => faker.datatype.boolean();

export const getSearchStaticContentResponseMock = (
  overrideResponse: Partial<StaticContentDtoPagedResponseDto> = {}
): StaticContentDtoPagedResponseDto => ({
  data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    id: faker.number.int({ min: undefined, max: undefined }),
    type: faker.helpers.arrayElement(Object.values(StaticContentType)),
    key: faker.string.alpha({ length: { min: 10, max: 20 } }),
    status: faker.helpers.arrayElement(Object.values(StaticContentStatus)),
    readAccess: faker.helpers.arrayElement(Object.values(StaticContentReadAccess)),
    editorRoles: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
    readerRoles: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
    createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
    createdByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
    statusChangedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
    statusChangedByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
    lastModifiedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
    lastModifiedByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  })),
  pageNumber: faker.number.int({ min: undefined, max: undefined }),
  pageSize: faker.number.int({ min: undefined, max: undefined }),
  totalCount: faker.number.int({ min: undefined, max: undefined }),
  totalPages: faker.number.int({ min: undefined, max: undefined }),
  ...overrideResponse,
});

export const getGetStaticContentLanguageResponseMock = (): StaticContentLanguageDto => ({
  ...{ ...{ content: faker.string.alpha({ length: { min: 10, max: 20 } }), format: faker.helpers.arrayElement(Object.values(StaticContentFormat)) } },
  staticContentId: faker.number.int({ min: undefined, max: undefined }),
  languageCode: faker.string.alpha({ length: { min: 10, max: 20 } }),
  createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
  createdByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  lastModifiedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
  lastModifiedUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
});

export const getCreateStaticContentLanguageResponseMock = (): StaticContentLanguageDto => ({
  ...{ ...{ content: faker.string.alpha({ length: { min: 10, max: 20 } }), format: faker.helpers.arrayElement(Object.values(StaticContentFormat)) } },
  staticContentId: faker.number.int({ min: undefined, max: undefined }),
  languageCode: faker.string.alpha({ length: { min: 10, max: 20 } }),
  createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
  createdByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  lastModifiedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
  lastModifiedUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
});

export const getUpdateStaticContentLanguageResponseMock = (): StaticContentLanguageDto => ({
  ...{ ...{ content: faker.string.alpha({ length: { min: 10, max: 20 } }), format: faker.helpers.arrayElement(Object.values(StaticContentFormat)) } },
  staticContentId: faker.number.int({ min: undefined, max: undefined }),
  languageCode: faker.string.alpha({ length: { min: 10, max: 20 } }),
  createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
  createdByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  lastModifiedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
  lastModifiedUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
});

export const getDeleteStaticContentLanguageResponseMock = (): boolean => faker.datatype.boolean();

export const getGetStaticContentLanguagesResponseMock = (): StaticContentLanguageDto[] | null =>
  Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    ...{
      ...{ content: faker.string.alpha({ length: { min: 10, max: 20 } }), format: faker.helpers.arrayElement(Object.values(StaticContentFormat)) },
    },
    staticContentId: faker.number.int({ min: undefined, max: undefined }),
    languageCode: faker.string.alpha({ length: { min: 10, max: 20 } }),
    createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
    createdByUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
    lastModifiedDate: faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
    lastModifiedUserId: faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]),
  }));

export const getGetSupportedExternalLoginsResponseMock = (): SupportedExternalLoginDto[] | null =>
  Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    providerName: faker.string.alpha({ length: { min: 10, max: 20 } }),
    displayName: faker.string.alpha({ length: { min: 10, max: 20 } }),
    loginUrl: faker.string.alpha({ length: { min: 10, max: 20 } }),
  }));

export const getSearchExternalLoginsResponseMock = (
  overrideResponse: Partial<AdminExternalLoginDtoPagedResponseDto> = {}
): AdminExternalLoginDtoPagedResponseDto => ({
  data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    ...{
      ...{
        loginProvider: faker.string.alpha({ length: { min: 10, max: 20 } }),
        providerKey: faker.string.alpha({ length: { min: 10, max: 20 } }),
        providerDisplayName: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
    },
    userId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  })),
  pageNumber: faker.number.int({ min: undefined, max: undefined }),
  pageSize: faker.number.int({ min: undefined, max: undefined }),
  totalCount: faker.number.int({ min: undefined, max: undefined }),
  totalPages: faker.number.int({ min: undefined, max: undefined }),
  ...overrideResponse,
});

export const getRemoveExternalLoginResponseMock = (): boolean => faker.datatype.boolean();

export const getGetExternalLoginResultResponseMock = (overrideResponse: Partial<ExternalLoginSuccessDto> = {}): ExternalLoginSuccessDto => ({
  type: faker.helpers.arrayElement(Object.values(ExternalLoginSuccessType)),
  email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  userName: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  ...overrideResponse,
});

export const getCompleteExternalLoginResponseMock = (overrideResponse: Partial<LoginSuccessDto> = {}): LoginSuccessDto => ({
  type: faker.helpers.arrayElement(Object.values(LoginSuccessType)),
  accessToken: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  ...overrideResponse,
});

export const getCompleteExternalLoginRegistrationResponseMock = (overrideResponse: Partial<LoginSuccessDto> = {}): LoginSuccessDto => ({
  type: faker.helpers.arrayElement(Object.values(LoginSuccessType)),
  accessToken: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  ...overrideResponse,
});

export const getLogInResponseMock = (overrideResponse: Partial<LoginSuccessDto> = {}): LoginSuccessDto => ({
  type: faker.helpers.arrayElement(Object.values(LoginSuccessType)),
  accessToken: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  ...overrideResponse,
});

export const getRegisterResponseMock = (overrideResponse: Partial<LoginSuccessDto> = {}): LoginSuccessDto => ({
  type: faker.helpers.arrayElement(Object.values(LoginSuccessType)),
  accessToken: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  ...overrideResponse,
});

export const getLogOutResponseMock = (): boolean => faker.datatype.boolean();

export const getChangePasswordResponseMock = (): boolean => faker.datatype.boolean();

export const getChangeEmailResponseMock = (): boolean => faker.datatype.boolean();

export const getConfirmEmailChangeResponseMock = (): boolean => faker.datatype.boolean();

export const getResetPasswordResponseMock = (): boolean => faker.datatype.boolean();

export const getNewPasswordResponseMock = (overrideResponse: Partial<LoginSuccessDto> = {}): LoginSuccessDto => ({
  type: faker.helpers.arrayElement(Object.values(LoginSuccessType)),
  accessToken: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]), undefined]),
  ...overrideResponse,
});

export const getVerifyCodeResponseMock = (): string | null =>
  faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]);

export const getGetAccessTokenResponseMock = (): string | null =>
  faker.helpers.arrayElement([faker.string.alpha({ length: { min: 10, max: 20 } }), null]);

export const getRequestVerificationEmailResponseMock = (): boolean => faker.datatype.boolean();

export const getVerifyEmailResponseMock = (): boolean => faker.datatype.boolean();

export const getRequestMagicLinkEmailResponseMock = (): boolean => faker.datatype.boolean();

export const getGetDevicesResponseMock = (): DeviceDto[] | null =>
  Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    lastSeen: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
    ipAddress: faker.string.alpha({ length: { min: 10, max: 20 } }),
    details: faker.string.alpha({ length: { min: 10, max: 20 } }),
  }));

export const getRevokeDeviceResponseMock = (): boolean => faker.datatype.boolean();

export const getGetProfileResponseMock = (overrideResponse: Partial<ProfileDto> = {}): ProfileDto => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  email: faker.string.alpha({ length: { min: 10, max: 20 } }),
  userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getUpdateMyProfileResponseMock = (overrideResponse: Partial<ProfileDto> = {}): ProfileDto => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  email: faker.string.alpha({ length: { min: 10, max: 20 } }),
  userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getSearchMyNotificationsResponseMock = (): NotificationSearchResultsDto => ({
  ...{
    ...{
      data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        id: faker.number.int({ min: undefined, max: undefined }),
        timestamp: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
        status: faker.helpers.arrayElement(Object.values(NotificationStatus)),
        type: faker.helpers.arrayElement(Object.values(NotificationType)),
        data: {
          [faker.string.alphanumeric(5)]: {},
        },
      })),
      pageNumber: faker.number.int({ min: undefined, max: undefined }),
      pageSize: faker.number.int({ min: undefined, max: undefined }),
      totalCount: faker.number.int({ min: undefined, max: undefined }),
      totalPages: faker.number.int({ min: undefined, max: undefined }),
    },
  },
  unreadCount: faker.number.int({ min: undefined, max: undefined }),
});

export const getMarkAllMyNotificationsAsReadResponseMock = (): boolean => faker.datatype.boolean();

export const getMarkMyNotificationAsReadResponseMock = (): boolean => faker.datatype.boolean();

export const getGetMyUserClaimsResponseClaimDtoMock = (overrideResponse: Partial<ClaimDto> = {}): ClaimDto => ({
  ...{ type: faker.string.alpha({ length: { min: 10, max: 20 } }), value: faker.string.alpha({ length: { min: 10, max: 20 } }) },
  ...overrideResponse,
});

export const getGetMyUserClaimsResponseUserClaimDtoMock = (overrideResponse: Partial<UserClaimDto> = {}): UserClaimDto => ({
  ...{
    ...{ ...{ type: faker.string.alpha({ length: { min: 10, max: 20 } }), value: faker.string.alpha({ length: { min: 10, max: 20 } }) } },
    userId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  },
  ...overrideResponse,
});

export const getGetMyUserClaimsResponseMock = (overrideResponse: Partial<ClaimDtoPagedResponseDto> = {}): ClaimDtoPagedResponseDto => ({
  data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.helpers.arrayElement([{ ...getGetMyUserClaimsResponseClaimDtoMock() }, { ...getGetMyUserClaimsResponseUserClaimDtoMock() }])
  ),
  pageNumber: faker.number.int({ min: undefined, max: undefined }),
  pageSize: faker.number.int({ min: undefined, max: undefined }),
  totalCount: faker.number.int({ min: undefined, max: undefined }),
  totalPages: faker.number.int({ min: undefined, max: undefined }),
  ...overrideResponse,
});

export const getGetMyUserSettingsResponseMock = (): UserSettingDto[] | null =>
  Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    key: faker.string.alpha({ length: { min: 10, max: 20 } }),
    value: faker.string.alpha({ length: { min: 10, max: 20 } }),
    createdDate: faker.helpers.arrayElement([
      faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
      undefined,
    ]),
    lastModifiedDate: faker.helpers.arrayElement([
      faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
      undefined,
    ]),
  }));

export const getSetMyUserSettingResponseMock = (overrideResponse: Partial<UserSettingDto> = {}): UserSettingDto => ({
  key: faker.string.alpha({ length: { min: 10, max: 20 } }),
  value: faker.string.alpha({ length: { min: 10, max: 20 } }),
  createdDate: faker.helpers.arrayElement([
    faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
    undefined,
  ]),
  lastModifiedDate: faker.helpers.arrayElement([
    faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetMyExternalLoginsResponseExternalLoginDtoMock = (overrideResponse: Partial<ExternalLoginDto> = {}): ExternalLoginDto => ({
  ...{
    loginProvider: faker.string.alpha({ length: { min: 10, max: 20 } }),
    providerKey: faker.string.alpha({ length: { min: 10, max: 20 } }),
    providerDisplayName: faker.string.alpha({ length: { min: 10, max: 20 } }),
  },
  ...overrideResponse,
});

export const getGetMyExternalLoginsResponseAdminExternalLoginDtoMock = (
  overrideResponse: Partial<AdminExternalLoginDto> = {}
): AdminExternalLoginDto => ({
  ...{
    ...{
      ...{
        loginProvider: faker.string.alpha({ length: { min: 10, max: 20 } }),
        providerKey: faker.string.alpha({ length: { min: 10, max: 20 } }),
        providerDisplayName: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
    },
    userId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  },
  ...overrideResponse,
});

export const getGetMyExternalLoginsResponseMock = ():
  | GetMyExternalLogins200OneItem[]
  | null
  | GetMyExternalLogins200TwoItem[]
  | null
  | GetMyExternalLogins200ThreeItem[]
  | null =>
  faker.helpers.arrayElement([
    Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.helpers.arrayElement([
        { ...getGetMyExternalLoginsResponseExternalLoginDtoMock() },
        { ...getGetMyExternalLoginsResponseAdminExternalLoginDtoMock() },
      ])
    ),
    Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.helpers.arrayElement([
        { ...getGetMyExternalLoginsResponseExternalLoginDtoMock() },
        { ...getGetMyExternalLoginsResponseAdminExternalLoginDtoMock() },
      ])
    ),
    Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.helpers.arrayElement([
        { ...getGetMyExternalLoginsResponseExternalLoginDtoMock() },
        { ...getGetMyExternalLoginsResponseAdminExternalLoginDtoMock() },
      ])
    ),
  ]);

export const getRemoveMyExternalLoginResponseMock = (): boolean => faker.datatype.boolean();

export const getGetUserResponsePublicUserDtoMock = (overrideResponse: Partial<PublicUserDto> = {}): PublicUserDto => ({
  ...{
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
    createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
  },
  ...overrideResponse,
});

export const getGetUserResponseAdminUserDtoMock = (overrideResponse: Partial<AdminUserDto> = {}): AdminUserDto => ({
  ...{
    ...{
      ...{
        ...{
          ...{
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
            createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
          },
        },
        email: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
    },
    lastModifiedDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
    lockoutEnd: faker.helpers.arrayElement([
      faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
      undefined,
    ]),
  },
  ...overrideResponse,
});

export const getGetUserResponsePrivilegedUserDtoMock = (overrideResponse: Partial<PrivilegedUserDto> = {}): PrivilegedUserDto => ({
  ...{
    ...{
      ...{
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
        createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
      },
    },
    email: faker.string.alpha({ length: { min: 10, max: 20 } }),
  },
  ...overrideResponse,
});

export const getGetUserResponseMock = (): GetUser200One | GetUser200Two | GetUser200Three =>
  faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      { ...getGetUserResponsePublicUserDtoMock() },
      { ...getGetUserResponseAdminUserDtoMock() },
      { ...getGetUserResponsePrivilegedUserDtoMock() },
    ]),
    faker.helpers.arrayElement([
      { ...getGetUserResponsePublicUserDtoMock() },
      { ...getGetUserResponseAdminUserDtoMock() },
      { ...getGetUserResponsePrivilegedUserDtoMock() },
    ]),
    faker.helpers.arrayElement([
      { ...getGetUserResponsePublicUserDtoMock() },
      { ...getGetUserResponseAdminUserDtoMock() },
      { ...getGetUserResponsePrivilegedUserDtoMock() },
    ]),
  ]);

export const getUpdateUserResponseMock = (): AdminUserDto => ({
  ...{
    ...{
      ...{
        ...{
          id: faker.string.alpha({ length: { min: 10, max: 20 } }),
          userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
          createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
        },
      },
      email: faker.string.alpha({ length: { min: 10, max: 20 } }),
    },
  },
  lastModifiedDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
  lockoutEnd: faker.helpers.arrayElement([
    faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
    undefined,
  ]),
});

export const getDeleteUserResponseMock = (): boolean => faker.datatype.boolean();

export const getGetUserByUserNameResponsePublicUserDtoMock = (overrideResponse: Partial<PublicUserDto> = {}): PublicUserDto => ({
  ...{
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
    createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
  },
  ...overrideResponse,
});

export const getGetUserByUserNameResponseAdminUserDtoMock = (overrideResponse: Partial<AdminUserDto> = {}): AdminUserDto => ({
  ...{
    ...{
      ...{
        ...{
          ...{
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
            createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
          },
        },
        email: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
    },
    lastModifiedDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
    lockoutEnd: faker.helpers.arrayElement([
      faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
      undefined,
    ]),
  },
  ...overrideResponse,
});

export const getGetUserByUserNameResponsePrivilegedUserDtoMock = (overrideResponse: Partial<PrivilegedUserDto> = {}): PrivilegedUserDto => ({
  ...{
    ...{
      ...{
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
        createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
      },
    },
    email: faker.string.alpha({ length: { min: 10, max: 20 } }),
  },
  ...overrideResponse,
});

export const getGetUserByUserNameResponseMock = (): GetUserByUserName200One | GetUserByUserName200Two | GetUserByUserName200Three =>
  faker.helpers.arrayElement([
    faker.helpers.arrayElement([
      { ...getGetUserByUserNameResponsePublicUserDtoMock() },
      { ...getGetUserByUserNameResponseAdminUserDtoMock() },
      { ...getGetUserByUserNameResponsePrivilegedUserDtoMock() },
    ]),
    faker.helpers.arrayElement([
      { ...getGetUserByUserNameResponsePublicUserDtoMock() },
      { ...getGetUserByUserNameResponseAdminUserDtoMock() },
      { ...getGetUserByUserNameResponsePrivilegedUserDtoMock() },
    ]),
    faker.helpers.arrayElement([
      { ...getGetUserByUserNameResponsePublicUserDtoMock() },
      { ...getGetUserByUserNameResponseAdminUserDtoMock() },
      { ...getGetUserByUserNameResponsePrivilegedUserDtoMock() },
    ]),
  ]);

export const getSearchUsersResponsePublicUserDtoMock = (overrideResponse: Partial<PublicUserDto> = {}): PublicUserDto => ({
  ...{
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
    createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
  },
  ...overrideResponse,
});

export const getSearchUsersResponseAdminUserDtoMock = (overrideResponse: Partial<AdminUserDto> = {}): AdminUserDto => ({
  ...{
    ...{
      ...{
        ...{
          ...{
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
            createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
          },
        },
        email: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
    },
    lastModifiedDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
    lockoutEnd: faker.helpers.arrayElement([
      faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
      undefined,
    ]),
  },
  ...overrideResponse,
});

export const getSearchUsersResponsePrivilegedUserDtoMock = (overrideResponse: Partial<PrivilegedUserDto> = {}): PrivilegedUserDto => ({
  ...{
    ...{
      ...{
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
        createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
      },
    },
    email: faker.string.alpha({ length: { min: 10, max: 20 } }),
  },
  ...overrideResponse,
});

export const getSearchUsersResponseMock = (overrideResponse: Partial<PublicUserDtoPagedResponseDto> = {}): PublicUserDtoPagedResponseDto => ({
  data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.helpers.arrayElement([
      { ...getSearchUsersResponsePublicUserDtoMock() },
      { ...getSearchUsersResponseAdminUserDtoMock() },
      { ...getSearchUsersResponsePrivilegedUserDtoMock() },
    ])
  ),
  pageNumber: faker.number.int({ min: undefined, max: undefined }),
  pageSize: faker.number.int({ min: undefined, max: undefined }),
  totalCount: faker.number.int({ min: undefined, max: undefined }),
  totalPages: faker.number.int({ min: undefined, max: undefined }),
  ...overrideResponse,
});

export const getGetUsersByIdsResponsePublicUserDtoMock = (overrideResponse: Partial<PublicUserDto> = {}): PublicUserDto => ({
  ...{
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
    createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
  },
  ...overrideResponse,
});

export const getGetUsersByIdsResponseAdminUserDtoMock = (overrideResponse: Partial<AdminUserDto> = {}): AdminUserDto => ({
  ...{
    ...{
      ...{
        ...{
          ...{
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
            createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
          },
        },
        email: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
    },
    lastModifiedDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
    lockoutEnd: faker.helpers.arrayElement([
      faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
      undefined,
    ]),
  },
  ...overrideResponse,
});

export const getGetUsersByIdsResponsePrivilegedUserDtoMock = (overrideResponse: Partial<PrivilegedUserDto> = {}): PrivilegedUserDto => ({
  ...{
    ...{
      ...{
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
        createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
      },
    },
    email: faker.string.alpha({ length: { min: 10, max: 20 } }),
  },
  ...overrideResponse,
});

export const getGetUsersByIdsResponseMock = ():
  | GetUsersByIds200OneItem[]
  | null
  | GetUsersByIds200TwoItem[]
  | null
  | GetUsersByIds200ThreeItem[]
  | null =>
  faker.helpers.arrayElement([
    Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.helpers.arrayElement([
        { ...getGetUsersByIdsResponsePublicUserDtoMock() },
        { ...getGetUsersByIdsResponseAdminUserDtoMock() },
        { ...getGetUsersByIdsResponsePrivilegedUserDtoMock() },
      ])
    ),
    Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.helpers.arrayElement([
        { ...getGetUsersByIdsResponsePublicUserDtoMock() },
        { ...getGetUsersByIdsResponseAdminUserDtoMock() },
        { ...getGetUsersByIdsResponsePrivilegedUserDtoMock() },
      ])
    ),
    Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
      faker.helpers.arrayElement([
        { ...getGetUsersByIdsResponsePublicUserDtoMock() },
        { ...getGetUsersByIdsResponseAdminUserDtoMock() },
        { ...getGetUsersByIdsResponsePrivilegedUserDtoMock() },
      ])
    ),
  ]);

export const getGetRolesResponseMock = (): RoleDto[] | null =>
  Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    displayName: faker.string.alpha({ length: { min: 10, max: 20 } }),
    description: faker.string.alpha({ length: { min: 10, max: 20 } }),
  }));

export const getGetRolesForUserResponseMock = (): string[] | null =>
  Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => faker.string.alpha({ length: { min: 10, max: 20 } }));

export const getGetUsersInRoleResponseMock = (): AdminUserDto[] | null =>
  Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    ...{
      ...{
        ...{
          ...{
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            userName: faker.string.alpha({ length: { min: 10, max: 20 } }),
            createdDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
          },
        },
        email: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
    },
    lastModifiedDate: new Date(`${faker.date.past().toISOString().split(".")[0]}Z`),
    lockoutEnd: faker.helpers.arrayElement([
      faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
      undefined,
    ]),
  }));

export const getAddUserToRoleResponseMock = (): boolean => faker.datatype.boolean();

export const getRemoveUserFromRoleResponseMock = (): boolean => faker.datatype.boolean();

export const getSearchClaimsResponseClaimDtoMock = (overrideResponse: Partial<ClaimDto> = {}): ClaimDto => ({
  ...{ type: faker.string.alpha({ length: { min: 10, max: 20 } }), value: faker.string.alpha({ length: { min: 10, max: 20 } }) },
  ...overrideResponse,
});

export const getSearchClaimsResponseUserClaimDtoMock = (overrideResponse: Partial<UserClaimDto> = {}): UserClaimDto => ({
  ...{
    ...{ ...{ type: faker.string.alpha({ length: { min: 10, max: 20 } }), value: faker.string.alpha({ length: { min: 10, max: 20 } }) } },
    userId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  },
  ...overrideResponse,
});

export const getSearchClaimsResponseMock = (overrideResponse: Partial<ClaimDtoPagedResponseDto> = {}): ClaimDtoPagedResponseDto => ({
  data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.helpers.arrayElement([{ ...getSearchClaimsResponseClaimDtoMock() }, { ...getSearchClaimsResponseUserClaimDtoMock() }])
  ),
  pageNumber: faker.number.int({ min: undefined, max: undefined }),
  pageSize: faker.number.int({ min: undefined, max: undefined }),
  totalCount: faker.number.int({ min: undefined, max: undefined }),
  totalPages: faker.number.int({ min: undefined, max: undefined }),
  ...overrideResponse,
});

export const getSearchUserClaimsResponseMock = (overrideResponse: Partial<UserClaimDtoPagedResponseDto> = {}): UserClaimDtoPagedResponseDto => ({
  data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    ...{ ...{ type: faker.string.alpha({ length: { min: 10, max: 20 } }), value: faker.string.alpha({ length: { min: 10, max: 20 } }) } },
    userId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  })),
  pageNumber: faker.number.int({ min: undefined, max: undefined }),
  pageSize: faker.number.int({ min: undefined, max: undefined }),
  totalCount: faker.number.int({ min: undefined, max: undefined }),
  totalPages: faker.number.int({ min: undefined, max: undefined }),
  ...overrideResponse,
});

export const getGetUsersWithClaimResponseMock = (overrideResponse: Partial<StringPagedResponseDto> = {}): StringPagedResponseDto => ({
  data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
    faker.string.alpha({ length: { min: 10, max: 20 } })
  ),
  pageNumber: faker.number.int({ min: undefined, max: undefined }),
  pageSize: faker.number.int({ min: undefined, max: undefined }),
  totalCount: faker.number.int({ min: undefined, max: undefined }),
  totalPages: faker.number.int({ min: undefined, max: undefined }),
  ...overrideResponse,
});

export const getAddUserClaimResponseMock = (): boolean => faker.datatype.boolean();

export const getRemoveUserClaimResponseMock = (): boolean => faker.datatype.boolean();

export const getLockUserAccountResponseMock = (): boolean => faker.datatype.boolean();

export const getUnlockUserAccountResponseMock = (): boolean => faker.datatype.boolean();

export const getGetUserSettingsResponseMock = (): UserSettingDto[] | null =>
  Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    key: faker.string.alpha({ length: { min: 10, max: 20 } }),
    value: faker.string.alpha({ length: { min: 10, max: 20 } }),
    createdDate: faker.helpers.arrayElement([
      faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
      undefined,
    ]),
    lastModifiedDate: faker.helpers.arrayElement([
      faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
      undefined,
    ]),
  }));

export const getSetUserSettingResponseMock = (overrideResponse: Partial<UserSettingDto> = {}): UserSettingDto => ({
  key: faker.string.alpha({ length: { min: 10, max: 20 } }),
  value: faker.string.alpha({ length: { min: 10, max: 20 } }),
  createdDate: faker.helpers.arrayElement([
    faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
    undefined,
  ]),
  lastModifiedDate: faker.helpers.arrayElement([
    faker.helpers.arrayElement([new Date(`${faker.date.past().toISOString().split(".")[0]}Z`), null]),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetPublishedStaticContentMockHandler = (
  overrideResponse?:
    | PublishedStaticContentResultDto
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PublishedStaticContentResultDto> | PublishedStaticContentResultDto),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Content/published/:key/:languageCode",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetPublishedStaticContentResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetSupportedLanguagesMockHandler = (
  overrideResponse?:
    | StaticContentSupportedLanguageDto[]
    | null
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<StaticContentSupportedLanguageDto[] | null> | StaticContentSupportedLanguageDto[] | null),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Content/supported-languages",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetSupportedLanguagesResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getCreateStaticContentMockHandler = (
  overrideResponse?: StaticContentDto | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<StaticContentDto> | StaticContentDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Content",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getCreateStaticContentResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetStaticContentMockHandler = (
  overrideResponse?: StaticContentDto | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StaticContentDto> | StaticContentDto),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Content/:key",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetStaticContentResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getUpdateStaticContentMockHandler = (
  overrideResponse?: StaticContentDto | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<StaticContentDto> | StaticContentDto),
  options?: RequestHandlerOptions
) => {
  return http.put(
    "*/api/Content/:key",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getUpdateStaticContentResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getDeleteStaticContentMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    "*/api/Content/:key",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getDeleteStaticContentResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getSearchStaticContentMockHandler = (
  overrideResponse?:
    | StaticContentDtoPagedResponseDto
    | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<StaticContentDtoPagedResponseDto> | StaticContentDtoPagedResponseDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Content/search",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getSearchStaticContentResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetStaticContentLanguageMockHandler = (
  overrideResponse?:
    | StaticContentLanguageDto
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StaticContentLanguageDto> | StaticContentLanguageDto),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Content/:key/languages/:languageCode",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetStaticContentLanguageResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getCreateStaticContentLanguageMockHandler = (
  overrideResponse?:
    | StaticContentLanguageDto
    | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<StaticContentLanguageDto> | StaticContentLanguageDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Content/:key/languages/:languageCode",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getCreateStaticContentLanguageResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getUpdateStaticContentLanguageMockHandler = (
  overrideResponse?:
    | StaticContentLanguageDto
    | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<StaticContentLanguageDto> | StaticContentLanguageDto),
  options?: RequestHandlerOptions
) => {
  return http.put(
    "*/api/Content/:key/languages/:languageCode",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getUpdateStaticContentLanguageResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getDeleteStaticContentLanguageMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    "*/api/Content/:key/languages/:languageCode",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getDeleteStaticContentLanguageResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetStaticContentLanguagesMockHandler = (
  overrideResponse?:
    | StaticContentLanguageDto[]
    | null
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StaticContentLanguageDto[] | null> | StaticContentLanguageDto[] | null),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Content/:key/languages",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetStaticContentLanguagesResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetSupportedExternalLoginsMockHandler = (
  overrideResponse?:
    | SupportedExternalLoginDto[]
    | null
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SupportedExternalLoginDto[] | null> | SupportedExternalLoginDto[] | null),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/ExternalLogin/supported",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetSupportedExternalLoginsResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getSearchExternalLoginsMockHandler = (
  overrideResponse?:
    | AdminExternalLoginDtoPagedResponseDto
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<AdminExternalLoginDtoPagedResponseDto> | AdminExternalLoginDtoPagedResponseDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/ExternalLogin/search",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getSearchExternalLoginsResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getRemoveExternalLoginMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    "*/api/ExternalLogin/remove/:userId/:loginProvider/:providerKey",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getRemoveExternalLoginResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetExternalLoginResultMockHandler = (
  overrideResponse?:
    | ExternalLoginSuccessDto
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ExternalLoginSuccessDto> | ExternalLoginSuccessDto),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/ExternalLogin/result/:confirmationToken",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetExternalLoginResultResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getCompleteExternalLoginMockHandler = (
  overrideResponse?: LoginSuccessDto | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LoginSuccessDto> | LoginSuccessDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/ExternalLogin/complete/:confirmationToken",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getCompleteExternalLoginResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getCompleteExternalLoginRegistrationMockHandler = (
  overrideResponse?: LoginSuccessDto | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LoginSuccessDto> | LoginSuccessDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/ExternalLogin/register/:confirmationToken",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getCompleteExternalLoginRegistrationResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getLogInMockHandler = (
  overrideResponse?: LoginSuccessDto | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LoginSuccessDto> | LoginSuccessDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Identity/login",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getLogInResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getRegisterMockHandler = (
  overrideResponse?: LoginSuccessDto | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LoginSuccessDto> | LoginSuccessDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Identity/register",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getRegisterResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getLogOutMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Identity/logout",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getLogOutResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getChangePasswordMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Identity/change-password",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getChangePasswordResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getChangeEmailMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Identity/change-email",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getChangeEmailResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getConfirmEmailChangeMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Identity/confirm-email-change",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getConfirmEmailChangeResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getResetPasswordMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Identity/reset-password",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getResetPasswordResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getNewPasswordMockHandler = (
  overrideResponse?: LoginSuccessDto | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LoginSuccessDto> | LoginSuccessDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Identity/new-password",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getNewPasswordResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getVerifyCodeMockHandler = (
  overrideResponse?: string | null | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<string | null> | string | null),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Identity/verify-code",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getVerifyCodeResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetAccessTokenMockHandler = (
  overrideResponse?: string | null | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string | null> | string | null),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Identity/access-token",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetAccessTokenResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getRequestVerificationEmailMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Identity/request-verification-email",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getRequestVerificationEmailResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getVerifyEmailMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Identity/verify-email",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getVerifyEmailResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getRequestMagicLinkEmailMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Identity/request-magic-link",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getRequestMagicLinkEmailResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetDevicesMockHandler = (
  overrideResponse?: DeviceDto[] | null | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DeviceDto[] | null> | DeviceDto[] | null),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Identity/devices",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetDevicesResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getRevokeDeviceMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    "*/api/Identity/devices/:deviceId",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getRevokeDeviceResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetProfileMockHandler = (
  overrideResponse?: ProfileDto | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ProfileDto> | ProfileDto),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/users/me/profile",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetProfileResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getUpdateMyProfileMockHandler = (
  overrideResponse?: ProfileDto | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<ProfileDto> | ProfileDto),
  options?: RequestHandlerOptions
) => {
  return http.put(
    "*/api/users/me/profile",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getUpdateMyProfileResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getSearchMyNotificationsMockHandler = (
  overrideResponse?:
    | NotificationSearchResultsDto
    | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<NotificationSearchResultsDto> | NotificationSearchResultsDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/users/me/notifications",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getSearchMyNotificationsResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getMarkAllMyNotificationsAsReadMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.put(
    "*/api/users/me/notifications/mark-all-as-read",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getMarkAllMyNotificationsAsReadResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getMarkMyNotificationAsReadMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.put(
    "*/api/users/me/notifications/:id/mark-as-read",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getMarkMyNotificationAsReadResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetMyUserClaimsMockHandler = (
  overrideResponse?:
    | ClaimDtoPagedResponseDto
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ClaimDtoPagedResponseDto> | ClaimDtoPagedResponseDto),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/users/me/claims",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetMyUserClaimsResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetMyUserSettingsMockHandler = (
  overrideResponse?:
    | UserSettingDto[]
    | null
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserSettingDto[] | null> | UserSettingDto[] | null),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/users/me/settings",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetMyUserSettingsResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getSetMyUserSettingMockHandler = (
  overrideResponse?: UserSettingDto | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<UserSettingDto> | UserSettingDto),
  options?: RequestHandlerOptions
) => {
  return http.patch(
    "*/api/users/me/settings",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getSetMyUserSettingResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetMyExternalLoginsMockHandler = (
  overrideResponse?:
    | GetMyExternalLogins200OneItem[]
    | null
    | GetMyExternalLogins200TwoItem[]
    | null
    | GetMyExternalLogins200ThreeItem[]
    | null
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) =>
        | Promise<GetMyExternalLogins200OneItem[] | null | GetMyExternalLogins200TwoItem[] | null | GetMyExternalLogins200ThreeItem[] | null>
        | GetMyExternalLogins200OneItem[]
        | null
        | GetMyExternalLogins200TwoItem[]
        | null
        | GetMyExternalLogins200ThreeItem[]
        | null),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/users/me/external-logins",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetMyExternalLoginsResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getRemoveMyExternalLoginMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    "*/api/users/me/external-logins/:loginProvider/:providerKey",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getRemoveMyExternalLoginResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetUserMockHandler = (
  overrideResponse?:
    | GetUser200One
    | GetUser200Two
    | GetUser200Three
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<GetUser200One | GetUser200Two | GetUser200Three> | GetUser200One | GetUser200Two | GetUser200Three),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Users/:userId",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetUserResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getUpdateUserMockHandler = (
  overrideResponse?: AdminUserDto | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<AdminUserDto> | AdminUserDto),
  options?: RequestHandlerOptions
) => {
  return http.put(
    "*/api/Users/:userId",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getUpdateUserResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getDeleteUserMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    "*/api/Users/:userId",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getDeleteUserResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetUserByUserNameMockHandler = (
  overrideResponse?:
    | GetUserByUserName200One
    | GetUserByUserName200Two
    | GetUserByUserName200Three
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) =>
        | Promise<GetUserByUserName200One | GetUserByUserName200Two | GetUserByUserName200Three>
        | GetUserByUserName200One
        | GetUserByUserName200Two
        | GetUserByUserName200Three),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Users/user-name/:userName",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetUserByUserNameResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getSearchUsersMockHandler = (
  overrideResponse?:
    | PublicUserDtoPagedResponseDto
    | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PublicUserDtoPagedResponseDto> | PublicUserDtoPagedResponseDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Users/search",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getSearchUsersResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetUsersByIdsMockHandler = (
  overrideResponse?:
    | GetUsersByIds200OneItem[]
    | null
    | GetUsersByIds200TwoItem[]
    | null
    | GetUsersByIds200ThreeItem[]
    | null
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) =>
        | Promise<GetUsersByIds200OneItem[] | null | GetUsersByIds200TwoItem[] | null | GetUsersByIds200ThreeItem[] | null>
        | GetUsersByIds200OneItem[]
        | null
        | GetUsersByIds200TwoItem[]
        | null
        | GetUsersByIds200ThreeItem[]
        | null),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Users/get-by-ids",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetUsersByIdsResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetRolesMockHandler = (
  overrideResponse?: RoleDto[] | null | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<RoleDto[] | null> | RoleDto[] | null),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Users/roles",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetRolesResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetRolesForUserMockHandler = (
  overrideResponse?: string[] | null | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string[] | null> | string[] | null),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Users/:userId/roles",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetRolesForUserResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetUsersInRoleMockHandler = (
  overrideResponse?:
    | AdminUserDto[]
    | null
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminUserDto[] | null> | AdminUserDto[] | null),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Users/roles/:role",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetUsersInRoleResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getAddUserToRoleMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Users/roles/:role/:userId",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getAddUserToRoleResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getRemoveUserFromRoleMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    "*/api/Users/roles/:role/:userId",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getRemoveUserFromRoleResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getSearchClaimsMockHandler = (
  overrideResponse?:
    | ClaimDtoPagedResponseDto
    | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ClaimDtoPagedResponseDto> | ClaimDtoPagedResponseDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Users/claims/search",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getSearchClaimsResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getSearchUserClaimsMockHandler = (
  overrideResponse?:
    | UserClaimDtoPagedResponseDto
    | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<UserClaimDtoPagedResponseDto> | UserClaimDtoPagedResponseDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Users/user-claims/search",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getSearchUserClaimsResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetUsersWithClaimMockHandler = (
  overrideResponse?:
    | StringPagedResponseDto
    | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<StringPagedResponseDto> | StringPagedResponseDto),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Users/claim-users",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetUsersWithClaimResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getAddUserClaimMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Users/:userId/claims",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getAddUserClaimResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getRemoveUserClaimMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.delete(
    "*/api/Users/:userId/claims",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getRemoveUserClaimResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getLockUserAccountMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Users/:userId/lock",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getLockUserAccountResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getUnlockUserAccountMockHandler = (
  overrideResponse?: boolean | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<boolean> | boolean),
  options?: RequestHandlerOptions
) => {
  return http.post(
    "*/api/Users/:userId/unlock",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getUnlockUserAccountResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getGetUserSettingsMockHandler = (
  overrideResponse?:
    | UserSettingDto[]
    | null
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserSettingDto[] | null> | UserSettingDto[] | null),
  options?: RequestHandlerOptions
) => {
  return http.get(
    "*/api/Users/:userId/settings",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetUserSettingsResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};

export const getSetUserSettingMockHandler = (
  overrideResponse?: UserSettingDto | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<UserSettingDto> | UserSettingDto),
  options?: RequestHandlerOptions
) => {
  return http.put(
    "*/api/Users/:userId/settings",
    async info => {
      await delay(1000);

      return new HttpResponse(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getSetUserSettingResponseMock(),
        { status: 200, headers: { "Content-Type": "text/plain" } }
      );
    },
    options
  );
};
export const getLightNapWebApiMock = () => [
  getGetPublishedStaticContentMockHandler(),
  getGetSupportedLanguagesMockHandler(),
  getCreateStaticContentMockHandler(),
  getGetStaticContentMockHandler(),
  getUpdateStaticContentMockHandler(),
  getDeleteStaticContentMockHandler(),
  getSearchStaticContentMockHandler(),
  getGetStaticContentLanguageMockHandler(),
  getCreateStaticContentLanguageMockHandler(),
  getUpdateStaticContentLanguageMockHandler(),
  getDeleteStaticContentLanguageMockHandler(),
  getGetStaticContentLanguagesMockHandler(),
  getGetSupportedExternalLoginsMockHandler(),
  getSearchExternalLoginsMockHandler(),
  getRemoveExternalLoginMockHandler(),
  getGetExternalLoginResultMockHandler(),
  getCompleteExternalLoginMockHandler(),
  getCompleteExternalLoginRegistrationMockHandler(),
  getLogInMockHandler(),
  getRegisterMockHandler(),
  getLogOutMockHandler(),
  getChangePasswordMockHandler(),
  getChangeEmailMockHandler(),
  getConfirmEmailChangeMockHandler(),
  getResetPasswordMockHandler(),
  getNewPasswordMockHandler(),
  getVerifyCodeMockHandler(),
  getGetAccessTokenMockHandler(),
  getRequestVerificationEmailMockHandler(),
  getVerifyEmailMockHandler(),
  getRequestMagicLinkEmailMockHandler(),
  getGetDevicesMockHandler(),
  getRevokeDeviceMockHandler(),
  getGetProfileMockHandler(),
  getUpdateMyProfileMockHandler(),
  getSearchMyNotificationsMockHandler(),
  getMarkAllMyNotificationsAsReadMockHandler(),
  getMarkMyNotificationAsReadMockHandler(),
  getGetMyUserClaimsMockHandler(),
  getGetMyUserSettingsMockHandler(),
  getSetMyUserSettingMockHandler(),
  getGetMyExternalLoginsMockHandler(),
  getRemoveMyExternalLoginMockHandler(),
  getGetUserMockHandler(),
  getUpdateUserMockHandler(),
  getDeleteUserMockHandler(),
  getGetUserByUserNameMockHandler(),
  getSearchUsersMockHandler(),
  getGetUsersByIdsMockHandler(),
  getGetRolesMockHandler(),
  getGetRolesForUserMockHandler(),
  getGetUsersInRoleMockHandler(),
  getAddUserToRoleMockHandler(),
  getRemoveUserFromRoleMockHandler(),
  getSearchClaimsMockHandler(),
  getSearchUserClaimsMockHandler(),
  getGetUsersWithClaimMockHandler(),
  getAddUserClaimMockHandler(),
  getRemoveUserClaimMockHandler(),
  getLockUserAccountMockHandler(),
  getUnlockUserAccountMockHandler(),
  getGetUserSettingsMockHandler(),
  getSetUserSettingMockHandler(),
];
